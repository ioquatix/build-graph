<!DOCTYPE html>
<html>
	<head>
		
			<title>Build::Graph::Node</title>
		
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		
		<link rel="icon" type="image/png" href="../../../../_static/icon.png"/>
		<link rel="stylesheet" href="../../../../_static/site.css" type="text/css" media="screen"/>
		
		<script src="../../../../_components/jquery/jquery.min.js"></script>
		<script src="../../../../_components/jquery-syntax/jquery.syntax.min.js"></script>
		<script src="../../../../_components/mermaid/mermaid.min.js"></script>
		
		<script src="../../../../_static/links.js"></script>
		
		<script type="text/javascript">
		//<![CDATA[
			jQuery(function($) {
				$.syntax();
			});
			
			let isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
			let config = {theme: 'light'};
			if (isDarkMode) config.theme = 'dark';
			else config.theme = 'forest';
			mermaid.initialize(config);
		//]]>
		</script>
	</head>

	<body>
		<header> › <a class="link" href="../../../../index.html">Project</a> › <a class="link" href="../../../index.html">Source</a></header>
		
		<main>
			
	<h1>Build::Graph::Node</h1>
	
	<p>
		<code class="language-ruby">class Build::Graph::Node</code>
	</p>
	
	<p>This is essentialy a immutable key:</p>
	
	
	
	
	<section>
	<h2>Definitions</h2>
	
	<section id="Build::Graph::Node#initialize"><h3><code class="language-ruby">def initialize(inputs, outputs)</code></h3><details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def initialize(inputs, outputs)
	@inputs = inputs
	@outputs = outputs
end</code></pre>
					</details></section><section id="Build::Graph::Node#inherit_outputs?"><h3><code class="language-ruby">def inherit_outputs?</code></h3><p>Nodes that inherit outputs are special in the sense that outputs are not available until all child nodes have been evaluated.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def inherit_outputs?
	@outputs == :inherit
end</code></pre>
					</details></section><section id="Build::Graph::Node#modified_time"><h3><code class="language-ruby">def modified_time</code></h3><p>This computes the most recent modified time for all inputs.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def modified_time
	@inputs.map{|path| path.modified_time}.max
end</code></pre>
					</details></section><section id="Build::Graph::Node#dirty?"><h3><code class="language-ruby">def dirty?</code></h3><p>This is a canonical dirty function. All outputs must exist and must be newer than all inputs. This function is not efficient, in the sense that it must query all files on disk for last modified time.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def dirty?
	if inherit_outputs?
		return true
	elsif @inputs.count == 0 or @outputs.count == 0
		# If there are no inputs or no outputs we are always dirty:
		return true
		
		# I'm not entirely sure this is the correct approach. If input is a glob that matched zero items, but might match items that are older than outputs, what is the correct output from this function?
	else
		# Dirty if any inputs or outputs missing:
		return true if missing?
		
		# Dirty if input modified after any output:
		if input_modified_time = self.modified_time
			# Outputs should always be more recent than their inputs:
			return true if @outputs.any?{|output_path| output_path.modified_time &lt; input_modified_time}
		else
			# None of the inputs exist:
			true
		end
	end
	
	return false
end</code></pre>
					</details></section>	</section>
	
	

				
			<footer>Documentation generated by <a href="https://github.com/socketry/utopia-project">Utopia::Project</a>.</footer>
		</main>
	</body>
</html>

